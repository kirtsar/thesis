\chapter{Алгоритмические и вычислительные аспекты}\label{sec:algo}

\section{Шифрование, сохраняющее формат}
\label{sec:fpe}
    Шифрование, сохраняющее формат (FPE, Format preserving encryption~\cite{bellare2009format}, далее $\fpe$-схема)~--- алгоритм, позволяющий зашифровывать сообщения из произвольного конечного множества $\Dom$ таким образом, что результат зашифрования также лежит в множестве $\Dom$.
    Такой тип алгоритмов довольно востребован на практике, о чем свидетельствует большое количество статей и предложений, рассматривающих стойкость таких криптопримитивов~\cite{bellare2009format, lee2015format, NIST16}.
    При этом подобные алгоритмы часто подвергаются специфическим атакам, связанным, в том числе, и с возможным относительно малым размером области определения (см.~\cite{hoang2018curse, amon2021three}).
    Известны <<доказуемо стойкие>> (см.~\cite{katz2020introduction}) алгоритмы как для очень малых ($ \lvert \Dom \rvert \approx 2^{10}$), так и для очень больших областей определения (размер которых приближается к размеру области определения стандартных блочных шифров, либо превышает их, см. т.н. wide-block encryption), в то время как для <<средних>> областей определения всё ещё не существует одного предпочтительного подхода.
    В этом разделе мы рассмотрим один возможный подход к построению $\fpe$-схем, основанный на квазигрупповых операциях.

\subsection{Общее описание $\fpe$-схем}
    $\fpe$-схемы позволяют зашифровывать тексты с заданным форматом (6 десятичных цифр, номер кредитной карты, СНИЛС) таким образом, чтобы зашифрованное сообщение имело бы тот же формат, что и исходное. 
    Указанное свойство желательно, например, при шифровании баз данных, где поля записей имеют строго предписанный формат.
    Формализация данного требования выглядит следующим образом.
    \begin{definition}
        $\fpe$-схема~--- это тройка (вероятностных) алгоритмов $(\gen, \enc, \dec)$:
        \begin{itemize}
            \item (вероятностный) алгоритм генерации ключа $\gen$: на вход принимает пустую строку и возвращает ключ $K \in Keys$;
            \item (детерминированный) алгоритм зашифрования $\enc$: на вход принимает ключ $K$, параметр-настройку $t \in \Twk$ и сообщение $m \in \Dom$ и возвращает шифртекст $ct \in \Dom$:
            \[
                \enc : \Keys \times \Twk \times \Dom \to \Dom.
            \]
            \item (детерминированный) алгоритм расшифрования $\dec$: на вход принимает ключ $K$, параметр-настройку $t \in \Twk$ и шифртекст $ct \in \Dom$ и возвращает открытый текст-сообщение $m \in \Dom$:
            \[
                \dec : \Keys \times \Twk \times \Dom \to \Dom.
            \]
        \end{itemize}
        Для указанной тройки алгоритмов должно выполняться требование корректности расшифрования: для любого $K \sample \gen$ и любых $t \in \Twk$, $m \in \Dom$ выполнено равенство
        \[
            \dec_K^t(\enc_K^t(m)) = m.
        \] 
    \end{definition}
        
    \begin{remark}
        Введение дополнительного параметра $t \in \Twk$ обусловлено тем, что область определения $\Dom$ может быть слишком маленькой, что приведет к возможности атаки по словарю.
    \end{remark}

    \begin{remark}
        Множество $\Dom$ может быть устроено нестандартно. 
        К примеру, если необходимо шифровать номера банковских карточек, то на множество $\Dom$ налагаются следующие ограничения:
        \begin{itemize}
            \item формат номера~---~16 десятичных цифр.
            \item первые 6 цифр кодируют ID банка, выдавшего карточку (для многих приложений они должны храниться в открытом виде).
            \item последняя цифра является контрольной суммой (хранится в открытом виде)
        \end{itemize} 
        Таким образом, для зашифрования остаются 9 средних цифр в номере карточки, и в этом примере множество $\Dom$ задается как $ \Dom = \{0, \ldots 9 \}^{9} \approx 2^{30}$. 
    \end{remark}

    <<Обычный>> блочный шифр действует на множестве двоичных строк фиксированной длины (например, $\Dom = \{0, 1\}^{128}$ для алгоритма <<Кузнечик>>, см.~\cite{kuzn}), и результат шифрования элемента $m \in \Dom$ может оказаться вне требуемого множества: $\enc_K^t(m) \not\in \Dom$.
    В связи с этим актуальна задача разработки алгоритма, который по ключу $K$ и параметру $t$ порождал бы некоторую подстановку $\enc_K^t \in \SSS_{\Dom}$ со следующими желательными свойствами:
    \begin{itemize}
        \item операции $\enc_K^t$, $\dec_K^{t}$ быстро вычислимы;
        \item при случайном выборе ключа $k \sample \gen$ получаемое отображение $\enc_K^t(\cdot)$ вычислительно неотличимо от случайной подстановки $\pi \sample \SSS_{\Dom}$; 
        \item вероятность успешной атаки схемы мала даже для малых ($\lvert \Dom \rvert \approx 2^{20}$ и менее) областей определения.
    \end{itemize}

\subsection{Подход на основе квазигрупп}
    В работах~\cite{ctcrypt21, fpe22} был предложен подход на основе квазигрупповых операций сдвига.
    В качестве базовой сложной задачи предлагается рассматривать задачу различения случайной подстановки от структурированной: пусть дана некоторая квазигруппа $Q$, мы хотим измерить, насколько композиция квазигрупповых операций (например, серия умножений слева на случайные элементы квазигруппы) похоже на случайную перестановку на множестве $Q$.
    Постановка задачи в несколько неформальном описании может быть представлена следующим образом (больше о теоретико-сложностных сведениях и <<доказуемой стойкости>> криптографических примитивов и протоколов можно посмотреть, например, в~\cite{katz2020introduction}).
    \begin{enumerate}
        \item Противник $\mathcal{A}$ (некоторый вероятностный алгоритм) взаимодействует с оракулом $\mathcal{O}$.
        Перед началом взаимодействия оракул <<подбрасывает монетку>> (выбирает случайный равновероятный бит $b \in \{0, 1\}$).
        \begin{itemize}
            \item Если бит $b = 0$, оракул выбирает случайную подстановку $\pi \in \SSS_Q$ на множестве $Q$ и реализует функцию $f$ как $f(x) = \pi(x)$.
            \item Если бит $b = 1$, оракул выбирает $\lambda$ случайных элементов $q_i \sample Q$, $i = 1, \ldots, \lambda$ и реализует функцию $f$ как
            \[
                f(x) = L_{q_1} \left( L_{q_2} \left( \ldots L_{q_{\lambda}}(x) \ldots \right) \right).
            \]
        \end{itemize}
        \item На запрос противника $x$ оракул $\mathcal{O}$ отвечает $f(x)$.
        \item Изучая ответы оракула, противник должен понять, какой бит выбрал противник до начала взаимодействия. 
        Вероятность противника оценивается как функция от параметров <<количество запросов к оракулу>> и <<количество тактов вычислений противника>>.
    \end{enumerate}
    Если противник может угадать бит $b$ с высокой вероятностью, то он способен отличать истинно случайную подстановку $\pi \in \SSS_Q$ от структурированной 
    \[
        f(x) = L_{q_1} \left( L_{q_2} \left( \ldots L_{q_{\lambda}}(x) \ldots \right) \right).
    \]

    Успех противника зависит от структуры используемой квазигруппы. 
    Так, если, например, задать квазигруппу $(Q, \circ) = (\ZZ_{2^n}, +)$, то полученная структурированная подстановка будет тривиально отличима от случайной, поскольку в таком случае <<левым умножением>> является сложение поданного на вход элемента со случайными элементами $L_q(x) = q + x$, и полученное преобразование будет линейным:
    \[
        f(x + y) - f(x) = y,
    \]
    что позволит легко отличить его от случайной подстановки.

    Свидетельством в пользу того, что рассматриваемая задача может быть сложной, является $\mathsf{NP}$-полнота задачи разрешимости уравнения над полиномиально полной квазигруппой.
    Тем не менее, такое наблюдение может давать теоретические гарантии лишь в <<худшем>> случае, ничего не говоря о <<генерической>> сложности задачи~\cite{kapovich2003generic}.
    Отметим также, что $L$-преобразования (и им родственные) рассматривались, в частности, в работах~\cite{QSP4, artamonov18, yash22}.
    Так, в работе~\cite{yash22} среди прочего показано, что для любой квазигрупповой операции $\circ$ при случайном независимом выборе элементов $k_i \in \Dom$ (при условии, что носитель распределения $k_i$ достаточно большой) распределение элемента $ct$ экспоненциально быстро сходится к равновероятному распределению на множестве $\Dom$.
    При этом результаты работы~\cite{yash22}, вообще говоря, не применимы к ситуации, в которых противник может получать образы различных адаптивно выбираемых $m$.

    Для того, чтобы получить $\fpe$-схему на основе описанной выше задачи необходимо задать пару алгоритмов $\enc$, $\dec$~--- отображений из $\Keys \times \Twk \times \Dom$ в $\Dom$.
    В работе~\cite{fpe22} был предложен следующий подход.
    Будем получать зашифрование элемента $m$ на ключе $K$ и параметре $t$ следующим образом.
    \begin{enumerate}
        \item На первом шаге по ключу $K \in \Keys$ и параметру $t \in \Twk$ построим с помощью псевдослучайной функции (см., например, функцию $\mathsf{PRF}$ из работы~\cite{alekseev16}) последовательность псевдослучайных элементов $q_1, \ldots, q_{\lambda} \in Q$.
        \item На втором шаге переведем с помощью левых квазигрупповых сдвигов заданное сообщение $m \in \Dom$ в сообщение
        \[
            ct = L_{q_1} \left( L_{q_2} \left( \ldots L_{q_{\lambda}}(m) \ldots \right) \right)
        \]
    \end{enumerate}
    Для расшифрования сообщения $ct$ достаточно также провести первый шаг, получив элементы $q_1, \ldots, q_{\lambda} \in Q$, а затем последовательно решить уравнения вида $q_i \circ x = y_i$ ($\lambda$ штук) и получить решение $m$.

    Сложность нахождения решения $m$ по заданным $(t, ct)$ и неизвестном $K$ в предложенной схеме обуславливается двумя факторами:
    \begin{enumerate}
        \item по известному $t$ и неизвестному $K$ трудно восстановить элементы $q_1, \ldots, q_{\lambda} \in Q$, полученные с помощью псевдослучайной функции (и даже отличить их от истинно случайных).
        \item При неизвестных $q_1, \ldots, q_{\lambda}$ трудно отличить результат применения структурированной перестановки 
        \[
            x \to L_{q_1} \circ (L_{q_2} \circ \ldots \circ (L_{q_{\lambda}} \circ x) \ldots )
        \]
        от результата применения случайной перестановки
        \[
            x \to \pi(x).
        \]
    \end{enumerate}

    Рассмотрим ограниченный класс квазигрупп, порожденных правильными семействами функций.
    Пусть $\ff$, $\gf$~--- два правильных семейства размера $n$ на прямом произведении $H^n$ групп $(H, +)$ (не обязательно абелевых).
    Как было отмечено выше (см. утверждение~\ref{propos:bijection}), операция $\sigma_{\ff}(\xx) = \xx \cdot \ff(\xx)$ является подстановкой на множестве $H^n$.
    В таком случае можно рассмотреть следующую операцию умножения $\circ$ на $H^n \times H^n$:
    \begin{equation}
        \label{eq:circ}
        (\xx, \yy) \to \xx \circ \yy = \sigma_{\ff}(\xx) + \sigma_{\gf}(\yy),
    \end{equation}
    где сложение $+$ понимается как покомпонентное сложение в группе $H$.

    Определенное таким образом умножение в $H^n$ может быть эффективно обращено используя следующее соображение.
    Рассмотрим подстановку $\sigma^{-1}_{\ff}$. 
    Как было отмечено в разделе~\ref{sec:properinverse}, подстановка $\sigma^{-1}_{\ff}$ также порождается некоторым правильным семейством $\widetilde{\ff}$ (которое было названо дуальным).
    Семейства $\ff$ и $\widetilde{\ff}$ связаны соотношением:
    \begin{equation}
        \label{eq:dual}
        \widetilde{\ff}(\xx) = (-\xx) + \sigma^{-1}_{\ff}(\xx), \quad \sigma_{\ff}(\xx) = \xx + \ff(\xx), \quad x \in H^n.
    \end{equation}

    Таким образом, если $\ff$ и $\widetilde{\ff}$~--- пара правильных семейств, связанных соотношением~(\ref{eq:dual}), и операция $\circ$ задается формулой~(\ref{eq:circ}), то операция $x \circ y$ обращается справа следующим образом:
    \[
        \xx = \sigma_{\widetilde{\ff}} \left( (\xx \circ \yy) - \sigma_{\gf}(\yy) \right).
    \]
    Аналогичным образом операция $\xx \circ \yy$ может быть обращена слева, используя <<дуальное>> к $\gf$ семейство $\widetilde{\gf}$.

    Из этих соображений вытекает, что как $L$-преобразование, так и обратное к нему $L^{-1}$ могут быть заданы с помощью правильных семейств дискретных функций, что позволяет перейти от табличного задания квазигруппы к функциональному.



\section{Алгоритм проверки правильности булевых семейств}

    В настоящем разделе мы рассмотрим один алгоритм проверки правильности булева семейства $\ff_n$, время работы которого существенно лучше \textquote{наивного} алгоритма.

\subsection{О сложности проверки правильности}
    Полученное в разделе~\ref{sec:uso} взаимно-однозначное соответствие между правильными семействами булевых функций и     $\uso$-ориентациями позволяет перенести часть результатов из теории, развитой в работах~\cite{USOphd,USOcomplexity,numberUSO}, на правильные семейства. 
    В частности, верны следующие утверждения.

    \TODO{верна ли теорема в такой формулировке? Или требование на размер схемы избыточно?}
    \begin{corollary}[{\cite{USOcomplexity}[теорема~5]}]
    \label{coroll:conp}
        Пусть семейство булевых функций задано в виде схемы из функциональных элементов полиномиального от параметра $n$ (размера семейства) размера.
        Тогда задача распознавания правильности семейства по его схеме из функциональных элементов является $\mathsf{coNP}$-полной.
    \end{corollary}

    Заметим, что указанное выше утверждение для случая задания функций в виде КНФ было известно и ранее (см. работу~\cite{nosov98}).
    При этом в определенных случаях задача проверки правильности может быть упрощена, в частности, за счет вида графа существенной зависимости~\cite{rykov10, rykov14}.

    Таким образом, нахождение быстрого (полиномиального по размеру семейства $n$) алгоритма проверки правильности семейства представляется маловероятным.
    Заметим, что \textquote{наивный} алгоритм проверки правильности требует $4^n$ операций вычисления значения семейства $\ff_n$ на наборе $\xx \in \EE_2^n$.

\subsection{Описание алгоритма}
    Рассмотрим алгоритм проверки правильности со сложностью $2 \cdot 3^n$ операций вычисления семейства $\ff_n$ на наборе $x$, который является следствием теоремы~\ref{thm:self_proper}.
    На вход алгоритму подаётся семейство булевых функций $\ff_n$ (например, в виде схем из функциональных элементов в некотором базисе).
    Алгоритм перебирает все проекции исходного семейства $\ff_n$, проверяя выполнение свойства несамодвойственности на какой-либо единственной паре внтиподальных наборов из области определения проекции.

    Если существует такая проекция, для которой свойство самодвойственности выполнено, то алгоритм останавливает работу и выдаёт результат <<семейство $\ff_n$ не является правильным>>, поскольку в таком случае по лемме~\ref{lemma:dual} найдётся самодвойственная проекция $\ff_n$, а значит, $\ff_n$ не является правильным.

    Если семейство $\ff_n$ проходит все проверки, то у нас есть гарантия, что для $\ff_n$ и всех его проекций не выполнено свойство самодвойственности: если бы существовал хотя бы один набор $\alpha$, для которого $\overline{F(\alpha)} = F(\bar{\alpha})$, то по лемме~\ref{lemma:dual} нашлась бы полностью самодвойственная проекция, что было исключено в ходе проверок.

    Таким образом, мы доказали корректность следующего алгоритма.

    \begin{Algo}
        Цикл по всем возможным наборам $\xx \in \EE_3^n$:
        \begin{enumerate}
            \item построить два набора $\yy, \zz \in \EE_2^n$ по правилу:
            \begin{itemize}
                \item если $x_i \in \{0, 1\}$, то положить $y_i \gets x_i$, $z_i \gets x_i$,
                \item в противном случае положить 
                $y_i \gets 0$, $z_i \gets 1$,
            \end{itemize}
            \item если существует номер $j$, что $y_j \ne z_j$, и $f_j(y) \ne f_j(z)$, вернуть ответ: \textquote{$\ff_n$ не является правильным}.
        \end{enumerate}
        Если все проверки пройдены успешно, то вернуть: \textquote{$\ff_n$ является правильным}.
    \end{Algo}

    Рассмотренный алгоритм позволяет снизить количество вычислений значения отображения $\ff_n$ в точке с $4^n$ до $2 \cdot 3^n$.
    Вопрос о возможном обобщении алгоритма со случая $k = 2$ на логики большей значности пока что остаётся открытым.


\section{Алгоритм построения представителей}



\section{Число правильных семейств размера $n$}

    Введем обозначения:
    \begin{itemize}
        \item $\Delta(n)$: количество булевых треугольных семейств размера $n$;
        \item $\Delta^{\loc}(n)$: количество булевых локально-треугольных семейств размера $n$;
        \item $\Delta^{\rec}(n)$: количество булевых рекурсивно-треугольных семейств размера $n$;
        \item $T(n)$: количество булевых правильных семейств размера $n$.
    \end{itemize}

    \begin{table}[h]
        \centering
        \captionsetup{justification=centering} % выравнивание подписи по-центру
        \caption{\label{tab:countfamilies} Число треугольных, рекурсивно, локально треугольных и правильных булевых семейств размера $n$.}
        \begin{tabular}{|c|c|c|c|c|}
            \toprule
            Размер $n$  & $\Delta(n)$ & $\Delta^{\rec}(n)$ & $\Delta^{\loc}(n)$ & $T(n)$ \\
            \midrule
            $n = 1$ & 2 & 2 & 2 & 2 \\
            \midrule
            $n = 2$ & 12 & 12 & 12 & 12 \\
            \midrule
            $n = 3$ & 488 & 680 & 680 & 744\\
            \midrule
            $n = 4$ & 481776 & 3209712 & 3349488 & 5541744 \\
            \midrule
            $n = 5$ & 157549032992 & ... & ... & 638560878292512 \\
            \bottomrule
        \end{tabular}
    \end{table}

    Числа треугольных семейства размера $n=5$ получено в работе~\cite{allen2014counting} (число CP-сетей размера $n=5$).
    Число правильных семейств размера $n=5$ получено в работе~\cite{mathew2013enumerating} (для числа замощений плоскости (паркетов)), а также в работах~\cite{bosshard2017pseudo, USOphd} (для числа одностоковых ориентаций).

    

    \begin{table}[h]
        \centering
        \captionsetup{justification=centering} % выравнивание подписи по-центру
        \caption{\label{tab:countclasses} Число классов эквивалентности правильных булевых семейств размера $n$.}
        \begin{tabular}{|c|c|c|}
            \toprule
            Размер $n$ & Классы 1 & Классы 2 \\
            \midrule
            $n = 1$ & 1 & 1 \\
            \midrule
            $n = 2$ & 2 & 2 \\
            \midrule
            $n = 3$ & 19 & 10 \\
            \midrule
            $n = 4$ & 14614 & 1291 \\
            \bottomrule
        \end{tabular}
    \end{table}





% \subsection{Число ассоциативных троек для квазигрупп, заданных правильными семействами булевых функций}


% На множестве всех правильных семейств можно задать действие группы
% $\mathbb{Z}_2^n$ (см. теорему~\ref{thm:additivity}):
% \[
%     F \to F \oplus A
% \]

% Такое действие сохраняет число ассоциативных троек, заданных правильным семейством, 
% поэтому задача поиска числа ассоциативных троек для правильных семейств заданного размера сводится 
% к перебору орбит данного действия.

% Для правильных семейств булевых функций путем перебора неэквивалентных правильных семейств 
% были получены точные оценки минимального числа ассоциативных троек 
% для семейств размера ${m = 1, \ldots 4.}$ 
% Для $m = 5$ была получена оценка сверху. 
% Напомним, что для правильного семейства размера $m$ латинский квадрат, полученный с помощью этого семейства, имеет размер $n = 2^m.$

% \begin{table}[H]
%     \caption{Минимальное число ассоциативных троек для квазигрупп, 
%     порожденных правильными семействами булевых функций размера ${m \le 5}$}
%     \label{tab2}
%     \begin{center}
%     \begin{tabular}{c|c}
%         $n = 2^m$ & $a^*(n)$ \\ 
%         \hline
%         2 & 8 \\
%         4 & 32  \\
%         8 & 88 \\
%         16 & 256 \\
%         32 & $\le 1120$\\
%     \end{tabular}
%     \end{center}
% \end{table}

% Было получено количество правильных семейств, на которых достигается минимальное число ассоциативных троек. 
% При $m = 2$ минимальное число ассоциативных троек достигается на одной орбите (8 правильных семейств), представитель 
% \[
% \begin{bmatrix}
%     f_1(x_1, x_2) \\ 
%     f_2(x_1, x_2) 
% \end{bmatrix} = 
% \begin{bmatrix}
%     0 \\ 
%     x_1 
% \end{bmatrix}.
% \]

% При $m = 3$ минимальное число 
% ассоциативных троек достигается на 
% двух орбитах (64 правильных семейства), представители: 
% \[
%     \begin{bmatrix}
%         f_1(x_1, x_2, x_3) \\ 
%         f_2(x_1, x_2, x_3) \\ 
%         f_3(x_1, x_2, x_3) 
%     \end{bmatrix} = 
%     \begin{bmatrix} 
%         x_2x_3 \\ 
%         x_1 \oplus x_1x_3 \\ 
%         x_1 \oplus x_2 \oplus x_1x_2 
%     \end{bmatrix}
% \]

% \[
%     \begin{bmatrix}
%         f_1(x_1, x_2, x_3) \\ 
%         f_2(x_1, x_2, x_3) \\ 
%         f_3(x_1, x_2, x_3) 
%     \end{bmatrix} = 
%     \begin{bmatrix} 
%         x_2 \oplus x_2x_3 \\ 
%         x_3 \oplus x_1x_3 \\ 
%         x_1 \oplus x_1x_2 
%     \end{bmatrix}
% \]

% При $m = 4$ минимальное число ассоциативных троек 
% достигается на 56 орбитах (21504 правильных семейств).


% Количество ассоциативных троек в латинском квадрате,
% построенном по правильному семейству,
% сильно зависит от вида параметрических функций $\pi_i$ 
% в определении правильного семейства. 
% В частности, если положить все 
% $\pi_i(x_i, y_i) = a_i, a_i \in \mathbb{Z}_2, $
% то построенный латинский квадрат будет задавать 
% полностью ассоциативную структуру,
% и число ассоциативных троек, соответственно, 
% будет равно $(2^m)^3,$
% где $m$ --- размер правильного семейства.

% Для криптографических приложений желательно, 
% чтобы число параметрических подстановок 
% $\pi_i, \; i = 1, \ldots, n,$
% для которых число ассоциативных троек минимально, 
% было как можно больше.
% С этой целью было проанализировано количество 
% параметрических подстановок,
% на которых достигается минимальное число ассоциативных троек. 
% Для $m = 3$ для каждой функции из двух орбит 
% существует 36 параметрических подстановок,
% на которых достигается нижняя оценка числа ассоциативных троек. 
% Данные параметрические подстановки могут быть различны 
% для функций из одной и той же орбиты.

% Для $m = 4$ для 16 орбит (из 56) существует 
% только 2 параметрические подстановки,
% на которых достигается нижняя оценка числа ассоциативных троек,
% для 32 орбит существует 4 таких подстановки, 
% для 8 орбит существует 8 подстановок.  

% Дополнительно можно отметить,
% что минимальное число ассоциативных троек 
% для заданного семейства при $m = 2, 3, 4$ всегда чётно.