\chapter{Применение квазигрупп в криптографии и теории кодирования}\label{ch:ch3}

\section{Шифрование, сохраняющее формат}

\subsection{Общее описание}
    
    Шифрование, сохраняющее формат, позволяет зашифровывать тексты с заданным форматом (6 десятичных цифр, номер кредитной карты, СНИЛС) таким образом, чтобы зашифрованное сообщение имело бы тот же формат, что и исходное. 
    Указанное свойство желательно, например, при шифровании баз данных, где поля записей имеют строго предписанный формат.

    Формализация данного требования выглядит следующим образом.
    Шифрование сохраняющее формат (Format Preserving Encryption, FPE) определяется как пара детерминированных алгоритмов:
    \[
        E : \texttt{Keys} \times \texttt{Twk} \times \texttt{Dom} \to \texttt{Dom},
    \]
    \[
        D : \texttt{Keys} \times \texttt{Twk} \times \texttt{Dom} \to \texttt{Dom},
    \]
    таких что $D_k^t(E_k^t(m)) = m,$ 
    где $t \in \texttt{Twk}$~---~параметр блочного шифра, 
    ${k \in \texttt{Keys}}$~---~ключ, 
    $m \in \texttt{Dom}$~---~сообщение определенного формата; 
    $E_k^t, D_k^t$~---~взаимно-обратные перестановки на множестве $\texttt{Dom}.$ 
    Введение дополнительного параметра $t \in \texttt{Twk}$ обусловлено тем, что область определения $\texttt{Dom}$ может быть слишком маленькой, что приведет к возможности атаки по словарю.

    Множество $\texttt{Dom}$ может быть устроено нестандартно. 
    К примеру, если необходимо шифровать номера банковских карточек, то на множество $\texttt{Dom}$ налагаются следующие ограничения:

    \begin{itemize}
        \item Формат номера~---~16 десятичных цифр.
        \item Первые 6 цифр кодируют ID банка, выдавшего карточку (для многих приложений они должны храниться в открытом виде).
        \item Последняя цифра является контрольной суммой. 
        \item Кроме того, большинство приложений требуют, чтобы последние 4 цифры номера карточки также были в открытом виде.
    \end{itemize} 
    Таким образом, для зашифрования остаются 6 средних цифр в номере карточки, и в этом примере \texttt{Dom}~---~это 6-значные десятичные строки: 
    $ \texttt{Dom} = \{0, \ldots 9 \}^6.$ 

    Обычный блочный шифр действует на множестве двоичных строк фиксированной длины (например, $\{0, 1\}^{128}$ для алгоритма <<Кузнечик>>), и результат шифрования элемента $m \in \texttt{Dom}$ может оказаться вне требуемого множества: $$E_k(m) \not\in \texttt{Dom}.$$
    В связи с этим ставится задача разработать алгоритм, который по ключу $k$ порождал бы некоторую подстановку 
    $E_k \in S_{\texttt{Dom}}$ (за $S_{\texttt{Dom}}$ обозначена группа подстановок элементов $\texttt{Dom}$,  за $\in_R$~---~операция случайного равновероятного выбора элемента из множества) со следующими желательными свойствами:


    \begin{enumerate}
        \item Операции $E_k(m), \; E_k^{-1}(m)$~---~быстро вычислимы.
        \item При равновероятном выборе ключа $k \in_R \texttt{Keys}$ получаемое отображение $E_k(\cdot)$ вычислительно неотличимо от случайной подстановки ${\pi \in_R S_{\texttt{Dom}}.}$ 
        \item Вероятность успешной атаки схемы мала даже для малых ($|\texttt{Dom}| \approx 2^{20}$ и менее) областей определения.
    \end{enumerate}

\subsection{Подход на основе квазигрупп}
    В докладе~\cite{ctcrypt21} был предложен подход на основе квазигрупповой операции.
    Без ограничения общности можно предполагать, что $\texttt{Dom} = 2^n$ для некоторого (возможно, малого) $n.$

    В качестве сложной задачи предлагается рассматривать следующую.
    Пусть дана некоторая квазигруппа $Q,$ мы хотим измерить, насколько композиция квазигрупповых операций (например, серия умножений слева на случайные элементы квазигруппы) похоже на случайную перестановку на множестве $Q.$
    Формализовать данную постановку задачи можно в парадигме доказуемой стойкости (см., например,~\cite{katz2020introduction}) следующим образом.

    \begin{enumerate}
        \item Противник $\mathcal{A}$ (некоторый вероятностный алгоритм) взаимодействует с оракулом $\mathcal{O}.$

        \item Перед началом взаимодействия оракул <<подбрасывает монетку>> (выбирает случайный равновероятный бит $b \in \{0, 1\}$).

        \begin{itemize}

            \item Если бит $b = 0,$ оракул выбирает случайную подстановку $\pi \in S_Q$ на множестве $Q$
            и кладет $f(\cdot) = \pi(\cdot)$

            \item Если бит $b = 1,$ оракул выбирает $\lambda$ случайных элементов $q_i \in Q, \quad i = 1, \ldots, \lambda$ и кладет 
            \(
                f(x) = L_{q_1} \circ (L_{q_2} \circ \ldots \circ (L_{q_{\lambda}} \circ x) \ldots )
            \)

        \end{itemize}

        \item На запрос противника $x$ оракул $\mathcal{O}$ отвечает $f(x).$

        \item Изучая ответы оракула, противник должен понять, какой бит выбрал противник до начала взаимодействия. Вероятность противника оценивается как функция от параметров <<количество запросов к оракулу>> и <<количество тактов вычислений противника>>.
    \end{enumerate}

    Если противник может угадать бит $b$ с высокой вероятностью, то он способен отличать истинно случайную перестановку $\pi \in S_Q$ от структурированной 
    \(
        f(x) = L_{q_1} \circ (L_{q_2} \circ \ldots \circ (L_{q_{\lambda}} \circ x) \ldots ).
    \)

    Успех противника зависит от структуры используемой квазигруппы. 
    Так, если задать квазигруппу $(Q, \circ) = (\mathbb{Z}_{2^n}, +),$
    то полученная структурированная перестановка будет тривиально отличима от случайной, поскольку в таком случае левыми умножениями будут сложение со случайными элементами $L_q(x) = q + x,$ и полученное преобразование будет линейным в том смысле, что 
    \[
        f(x + y) - f(x) = y.
    \]

    Свидетельством в пользу того, что рассматриваемая задача может быть сложной, является NP-полнота задачи разрешимости уравнения над полиномиально полной квазигруппой.
    Тем не менее, такое наблюдение может давать теоретические гарантии лишь в <<худшем>> случае, ничего не говоря о <<генерической>> сложности задачи~\cite{kapovich2003generic}.

    Для того, чтобы получить алгоритм шифрования, сохраняющего формат, необходимо задать пару алгоритмов $E, D,$ действующих из $\texttt{Keys} \times \texttt{Twk} \times \texttt{Dom}$ в $\texttt{Dom}.$
    Как было отмечено выше, мы можем считать, что $\texttt{Dom} = \{0, 1\}^n$ для некоторого $n,$ например, $n = 30.$
    Введем структуру квазигруппы $Q$ на множестве $\{0, 1\}^n.$

    \begin{enumerate}
        \item На первом шаге по ключу $k \in \texttt{Keys}$ и параметру $t \in \texttt{Twk}$ мы строим последовательность псевдослучайных элементов $q_1, \ldots, q_{\lambda} \in Q.$
        Это можно сделать, например, с помощью псевдослучайной функции (PRF) из статьи~\cite{alekseev16};

        \item На втором шаге переведем заданное сообщение $m \in \texttt{Dom}$ в сообщение
        \[
            c = L_{q_1} \circ (L_{q_2} \circ \ldots \circ (L_{q_{\lambda}} \circ m) \ldots )
        \]
    \end{enumerate}

    Для расшифрования сообщения $c$ достаточно также провести первый шаг, получив элементы $q_1, \ldots, q_{\lambda} \in Q.$
    Затем последовательно решить уравнения вида $q_i \circ x = y_i$ ($\lambda$ штук) и получить решение $m.$

    Сложность нахождения решения $m$ по заданным $(t, c)$ обуславливается двумя факторами:
    \begin{enumerate}
        \item По известному $t$ и неизвестному $k$ трудно восстановить элементы $q_1, \ldots, q_{\lambda} \in Q,$ полученные с помощью псевдослучайной функции (и даже отличить их от истинно случайных).

        \item При неизвестных $q_1, \ldots, q_{\lambda}$ трудно отличить результат применения структурированной перестановки 
        \[
            x \to L_{q_1} \circ (L_{q_2} \circ \ldots \circ (L_{q_{\lambda}} \circ x) \ldots )
        \]
        от результата применения случайной перестановки
        \[
            x \to \pi(x).
        \]
    \end{enumerate}

